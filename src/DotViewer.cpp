// -----------------------------------------------------------------------------
//
// GAMCS -- Generalized Intelligence Model and Computer Simulation
//
// Copyright (C) 2013-2014, Andy Huang  <andyspider@126.com>
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.
//
// -----------------------------------------------------------------------------

#include <string>
#include <vector>
#include "gamcs/DotViewer.h"
#include "gamcs/Agent.h"
#include "gamcs/Storage.h"
#include "gamcs/StateInfoParser.h"

namespace gamcs
{

DotViewer::DotViewer(Storage *sg) :
        MemoryViewer(sg), last_state(Agent::INVALID_STATE), last_action(
                Agent::INVALID_ACTION)
{
}

DotViewer::~DotViewer()
{
}

void DotViewer::show()
{
    int re = storage->connect();
    if (re != 0)    // connect failed
    {
        WARNNING("DotViewer Show(): connect to storage failed!\n");
        return;
    }

    printf(
            "/* This is the dot file of agent memory automaticlly generated by DotViewer */\n\n");

    // generate dot syntax
    printf("digraph %s \n{\n", storage->getMemoryName().c_str());

    // memory info
    struct Memory_Info *memif = storage->getMemoryInfo();
    if (memif != NULL)
    {
        printf(
                "label=\"memory %s\\ndiscount rate: %.2f, threshold: %.2f, #states: %ld, #links: %ld\"\n",
                storage->getMemoryName().c_str(), memif->discount_rate,
                memif->threshold, memif->state_num, memif->lk_num);
        // store last status
        last_state = memif->last_st;
        last_action = memif->last_act;
        free(memif);    // free it, the memory struct are not a substaintial struct for running, it's just used to store meta-memory information
    }
    else
    {
        printf("Memory not found in storage!\n");
        printf("}\n");    // digraph
        storage->close();
        return;
    }

    // states info
    printf("node [color=black,shape=circle]\n");
    printf("rank=\"same\"\n");
    // print states info
    Agent::State st = storage->firstState();
    while (st != Agent::INVALID_STATE)    // get state value
    {
        struct State_Info_Header *stif = storage->getStateInfo(st);
        if (stif != NULL)
        {
            dotStateInfo(stif);
            free(stif);
            st = storage->nextState();
        }
        else
            ERROR("Show(): state: %" ST_FMT " information is NULL!\n", st);
    }
    printf("}\n");    // digraph
    storage->close();
}

void DotViewer::dotStateInfo(const struct State_Info_Header *sthd) const
{
    /* generated state example:
     *
     * subgraph state9
     * {
     *      rank="same"
     *      st9 [label="9"]
     *      subgraph
     *      {
     *          rank="sink"
     *          node [shape="point"]
     *          act0in9 [label=""]
     *          act1in9 [label=""]
     *          act0in9 -> act1in9 [style=dashed, dir=none]
     *      }
     *      st9 -> act0in9 [label="act: -1"]
     *      st9 -> act1in9 [label="act: 1"]
     * }
     *
     * act0in9 -> st8 [label="eat: 0 (count)"]
     * act1in9 -> st7 [label="eat: 0 (count)"]
     */

    if (sthd == NULL) return;

    std::string st_color;
    if (sthd->st == last_state)
        st_color = "#D3D300";    // highlight last state node
    else
        st_color = "black";

    std::vector<Agent::Action> acts(sthd->act_num);

    printf("\nsubgraph state%" ST_FMT "\n{\n", sthd->st);
    printf("rank=\"same\"\n");
    printf("st%" ST_FMT " [label=\"%" ST_FMT "\\n(%.2f)\", color=\"%s\"]\n", sthd->st, sthd->st,
            sthd->payoff, st_color.c_str());
    // action nodes and action ---> action
    printf("subgraph \n{\n");
    printf("rank=\"sink\"\n");    // env nodes should be drawing under state node
    printf("node [shape=\"point\"]\n");

    Action_Info_Header *achd, *pre_achd = NULL;
    StateInfoParser sparser(sthd);
    achd = sparser.firstAct();
    int i = 0;
    while (achd != NULL)
    {
        printf("act%sin%" ST_FMT " [label=\"\", height=0.3]\n",
                act2String(achd->act).c_str(), sthd->st);
        if (pre_achd != NULL)
        printf("act%sin%" ST_FMT " -> act%sin%" ST_FMT " [style=dashed, dir=none]\n",
                act2String(pre_achd->act).c_str(), sthd->st,
                act2String(achd->act).c_str(), sthd->st);

        acts[i++] = achd->act;    // save for using later
        pre_achd = achd;

        achd = sparser.nextAct();
    }
    printf("}\n");    // subgraph

    // state ---> actions
    for (unsigned long i = 0; i < sthd->act_num; i++)
    {
    if (sthd->st == last_state && acts[i] == last_action)    // highlight last action edge
    printf(
            "st%" ST_FMT " -> act%sin%" ST_FMT " [label=<<font color=\"#D3D300\">%" ACT_FMT "</font>>, color=\"#D3D300\", weight=2.]\n",
            sthd->st, act2String(acts[i]).c_str(), sthd->st, acts[i]);
    else
    printf(
            "st%" ST_FMT " -> act%sin%" ST_FMT " [label=<<font color=\"blue\">%" ACT_FMT "</font>>, color=\"blue\", weight=2.]\n",
            sthd->st, act2String(acts[i]).c_str(), sthd->st, acts[i]);

}

printf("}\n");    // end of subgraph state

EnvAction_Info *eaif = NULL;
achd = sparser.firstAct();    // restart from beginning
while (achd != NULL)
{
    eaif = sparser.firstEat();
    while (eaif != NULL)
    {
        printf(
                "act%sin%" ST_FMT " -> st%" ST_FMT " [label=<<font color=\"red\">%" ACT_FMT " (%ld)</font>>, color=\"red\", weight=1.]\n",
                act2String(achd->act).c_str(), sthd->st, eaif->nst,
                eaif->eat, eaif->count);

        eaif = sparser.nextEat();
    }

    achd = sparser.nextAct();
}
}

const std::string DotViewer::act2String(Agent::Action act) const
{
char tmp[28];
if (act >= 0)
{
    sprintf(tmp, "%" ACT_FMT, act);
    std::string str(tmp);
    return str;
}
else    // eat < 0, since dot doesn't support minus sign, so we convert '-' to '_'
{
    sprintf(tmp, "_%" ACT_FMT, -act);
    std::string str(tmp);
    return str;
}
}

void DotViewer::showState(Agent::State st)
{
int re = storage->connect();
if (re != 0)    // connect failed
{
    WARNNING("DotViewer ShowState(): connect to storage failed!\n");
    return;
}

printf(
        "/* This is the dot file of agent memory automaticlly generated by DotViewer */\n\n");

// generated dot file example:
/*
 * digraph Mouse_1 {
 * node [color=black,shape=circle]
 * rank="same"
 * st1 [label="1\n(3.00)"]
 *
 * subgraph {
 * rank="same"
 * eat1in1 [shape="point", label="", height=0.3]
 * eat0in1 [shape="point", label="", height=0.3]
 * eat1in1 -> eat0in1 [style=dashed, dir=none]
 * }
 * st1 -> eat1in1 [label=<<font color="blue">e: 1 (1)</font>>, color="blue", weight=3.]
 * st1 -> eat0in1 [label=<<font color="blue">e: 0 (4)</font>>, color="blue", weight=3.]
 *
 * eat1in1 -> st1 [label=<<font color="red">a: -1 (0.60)</font>>, color="red", weight=1.]
 * eat0in1 -> st2 [label=<<font color="red">a: 1 (2.74)</font>>, color="red", weight=1.]
 * st2 [label="2\n(1.00)"]
 * }
 */

printf("digraph %s_%" ST_FMT " \n{\n", storage->getMemoryName().c_str(), st);
// state info
printf("node [color=black,shape=circle]\n");
printf("rank=\"same\"\n");
printf("label=\"infoset of state %" ST_FMT " in memory %s\"\n", st,
        storage->getMemoryName().c_str());

struct State_Info_Header *sthd = storage->getStateInfo(st);
if (sthd != NULL)
{
    std::vector<Agent::Action> acts(sthd->act_num);

    printf("rank=\"same\"\n");
    printf("st%" ST_FMT " [label=\"%" ST_FMT "\\n(%.2f)\"]\n", sthd->st, sthd->st,
            sthd->payoff);
    // action nodes and action ---> action
    printf("subgraph \n{\n");
    printf("rank=\"same\"\n");    // env nodes should be drawing under state node
    printf("node [shape=\"point\"]\n");

    StateInfoParser sparser(sthd);
    Action_Info_Header *achd, *pre_achd = NULL;
    achd = sparser.firstAct();
    int i = 0;
    while (achd != NULL)
    {
        printf("act%sin%" ST_FMT " [label=\"\", height=0.3]\n",
                act2String(achd->act).c_str(), sthd->st);
        if (pre_achd != NULL)
        printf("act%sin%" ST_FMT " -> act%sin%" ST_FMT " [style=dashed, dir=none]\n",
                act2String(pre_achd->act).c_str(), sthd->st,
                act2String(achd->act).c_str(), sthd->st);

        acts[i++] = achd->act;    // save for using later
        pre_achd = achd;
        achd = sparser.nextAct();
    }
    printf("}\n");    // subgraph

    // state ---> actions
    for (unsigned long i = 0; i < sthd->act_num; i++)
    {
    printf(
            "st%" ST_FMT " -> act%sin%" ST_FMT " [label=<<font color=\"blue\">%" ACT_FMT "</font>>, color=\"blue\", weight=2.]\n",
            sthd->st, act2String(acts[i]).c_str(), sthd->st, acts[i]);
}

// actions ---> next states
EnvAction_Info *eaif = NULL;
achd = sparser.firstAct();    // restart from beginning
while (achd != NULL)
{
    eaif = sparser.firstEat();
    while (eaif != NULL)
    {
        printf(
                "act%sin%" ST_FMT " -> st%" ST_FMT " [label=<<font color=\"red\">%" ACT_FMT " (%ld)</font>>, color=\"red\", weight=1.]\n",
                act2String(achd->act).c_str(), sthd->st, eaif->nst,
                eaif->eat, eaif->count);
        // get the payoff of the next state, exclude self
        if (eaif->nst != sthd->st)
        {
            State_Info_Header *nstif = storage->getStateInfo(eaif->nst);
            if (nstif == NULL)    // shouldn't happen
                ERROR("next state: %" ST_FMT " returns NULL!\n", eaif->nst);

            printf("st%" ST_FMT " [label=\"%" ST_FMT "\\n(%.2f)\"]\n", eaif->nst,
                    eaif->nst, nstif->payoff);    // print out next state
            free(nstif);
        }

        eaif = sparser.nextEat();
    }

    achd = sparser.nextAct();
}

free(sthd);
}
else    // state not found
{
printf("state %" ST_FMT " not found in memory!\n", st);
}

printf("}\n");    // digraph
storage->close();
}

}    // namespace gamcs
