// -----------------------------------------------------------------------------
//
// GIMCS -- Generalized Intelligence Model and Computer Simulation
//
// Copyright (C) 2013-2014, Andy Huang  <andyspider@126.com>
//
// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.
//
// -----------------------------------------------------------------------------

#include <string>
#include "gimcs/DotViewer.h"
#include "gimcs/Agent.h"
#include "gimcs/Storage.h"
#include "gimcs/StateInfoParser.h"

namespace gimcs
{

DotViewer::DotViewer() :
        last_state(INVALID_STATE), last_action(INVALID_ACTION)
{
}

DotViewer::DotViewer(Storage *sg) :
        MemoryViewer(sg), last_state(INVALID_STATE), last_action(INVALID_ACTION)
{
}

DotViewer::~DotViewer()
{
}

void DotViewer::Show()
{
    int re = storage->Connect();
    if (re != 0)    // connect failed
    {
        WARNNING("DotViewer Show(): connect to storage failed!\n");
        return;
    }

    printf(
            "/* This is the dot file of agent memory automaticlly generated by DotViewer */\n\n");

    // generate dot syntax
    printf("digraph %s \n{\n", storage->GetMemoryName().c_str());

    // memory info
    struct Memory_Info *memif = storage->GetMemoryInfo();
    if (memif != NULL)
    {
        printf(
                "label=\"memory %s\\ndiscount rate: %.2f, threshold: %.2f, #states: %ld, #links: %ld\"\n",
                storage->GetMemoryName().c_str(), memif->discount_rate,
                memif->threshold, memif->state_num, memif->lk_num);
        // store last status
        last_state = memif->last_st;
        last_action = memif->last_act;
        free(memif);    // free it, the memory struct are not a substaintial struct for running, it's just used to store meta-memory information
    }
    else
    {
        printf("Memory not found in storage!\n");
        printf("}\n");    // digraph
        storage->Close();
        return;
    }

    // states info
    printf("node [color=black,shape=circle]\n");
    printf("rank=\"same\"\n");
    // print states info
    Agent::State st = storage->FirstState();
    while (st != INVALID_STATE)    // get state value
    {
        struct State_Info_Header *stif = storage->GetStateInfo(st);
        if (stif != NULL)
        {
            DotStateInfo(stif);
            free(stif);
            st = storage->NextState();
        }
        else
            ERROR("Show(): state: %ld information is NULL!\n", st);
    }
    printf("}\n");    // digraph
    storage->Close();
}

void DotViewer::DotStateInfo(const struct State_Info_Header *sthd) const
{
    /* generated state example:
     *
     * subgraph state9
     * {
     *      rank="same"
     *      st9 [label="9"]
     *      subgraph
     *      {
     *          rank="sink"
     *          node [shape="point"]
     *          act0in9 [label=""]
     *          act1in9 [label=""]
     *          act0in9 -> act1in9 [style=dashed, dir=none]
     *      }
     *      st9 -> act0in9 [label="act: -1"]
     *      st9 -> act1in9 [label="act: 1"]
     * }
     *
     * act0in9 -> st8 [label="eat: 0 (count)"]
     * act1in9 -> st7 [label="eat: 0 (count)"]
     */

    if (sthd == NULL) return;

    std::string st_color;
    if (sthd->st == last_state)
        st_color = "#D3D300";    // highlight last state node
    else
        st_color = "black";

    Agent::Action acts[sthd->act_num];

    printf("\nsubgraph state%ld\n{\n", sthd->st);
    printf("rank=\"same\"\n");
    printf("st%ld [label=\"%ld\\n(%.2f)\", color=\"%s\"]\n", sthd->st, sthd->st,
            sthd->payoff, st_color.c_str());
    // action nodes and action ---> action
    printf("subgraph \n{\n");
    printf("rank=\"sink\"\n");    // env nodes should be drawing under state node
    printf("node [shape=\"point\"]\n");

    Action_Info_Header *achd, *pre_achd = NULL;
    StateInfoParser sparser(sthd);
    achd = sparser.FirstAct();
    int i = 0;
    while (achd != NULL)
    {
        printf("act%sin%ld [label=\"\", height=0.3]\n",
                Act2String(achd->act).c_str(), sthd->st);
        if (pre_achd != NULL)
            printf("act%sin%ld -> act%sin%ld [style=dashed, dir=none]\n",
                    Act2String(pre_achd->act).c_str(), sthd->st,
                    Act2String(achd->act).c_str(), sthd->st);

        acts[i++] = achd->act;    // save for using later
        pre_achd = achd;

        achd = sparser.NextAct();
    }
    printf("}\n");    // subgraph

    // state ---> actions
    for (unsigned long i = 0; i < sthd->act_num; i++)
    {
        if (sthd->st == last_state && acts[i] == last_action)    // highlight last action edge
            printf(
                    "st%ld -> act%sin%ld [label=<<font color=\"#D3D300\">%ld</font>>, color=\"#D3D300\", weight=2.]\n",
                    sthd->st, Act2String(acts[i]).c_str(), sthd->st, acts[i]);
        else
            printf(
                    "st%ld -> act%sin%ld [label=<<font color=\"blue\">%ld</font>>, color=\"blue\", weight=2.]\n",
                    sthd->st, Act2String(acts[i]).c_str(), sthd->st, acts[i]);

    }
    printf("}\n");    // end of subgraph state

    EnvAction_Info *eaif = NULL;
    achd = sparser.FirstAct();    // restart from beginning
    while (achd != NULL)
    {
        eaif = sparser.FirstEat();
        while (eaif != NULL)
        {
            printf(
                    "act%sin%ld -> st%ld [label=<<font color=\"red\">%ld (%ld)</font>>, color=\"red\", weight=1.]\n",
                    Act2String(achd->act).c_str(), sthd->st, eaif->nst,
                    achd->act, eaif->count);

            eaif = sparser.NextEat();
        }

        achd = sparser.NextAct();
    }
}

const std::string DotViewer::Act2String(Agent::EnvAction eat) const
{
    char tmp[28];
    if (eat >= 0)
    {
        sprintf(tmp, "%ld", eat);
        std::string str(tmp);
        return str;
    }
    else    // eat < 0, since dot doesn't support minus sign, so we convert '-' to '_'
    {
        sprintf(tmp, "_%ld", -eat);
        std::string str(tmp);
        return str;
    }
}

void DotViewer::ShowState(Agent::State st)
{
    int re = storage->Connect();
    if (re != 0)    // connect failed
    {
        WARNNING("DotViewer ShowState(): connect to storage failed!\n");
        return;
    }

    printf(
            "/* This is the dot file of agent memory automaticlly generated by DotViewer */\n\n");

    // generated dot file example:
    /*
     * digraph Mouse_1 {
     * node [color=black,shape=circle]
     * rank="same"
     * st1 [label="1\n(3.00)"]
     *
     * subgraph {
     * rank="same"
     * eat1in1 [shape="point", label="", height=0.3]
     * eat0in1 [shape="point", label="", height=0.3]
     * eat1in1 -> eat0in1 [style=dashed, dir=none]
     * }
     * st1 -> eat1in1 [label=<<font color="blue">e: 1 (1)</font>>, color="blue", weight=3.]
     * st1 -> eat0in1 [label=<<font color="blue">e: 0 (4)</font>>, color="blue", weight=3.]
     *
     * eat1in1 -> st1 [label=<<font color="red">a: -1 (0.60)</font>>, color="red", weight=1.]
     * eat0in1 -> st2 [label=<<font color="red">a: 1 (2.74)</font>>, color="red", weight=1.]
     * st2 [label="2\n(1.00)"]
     * }
     */

    printf("digraph %s_%ld \n{\n", storage->GetMemoryName().c_str(), st);
    // state info
    printf("node [color=black,shape=circle]\n");
    printf("rank=\"same\"\n");
    printf("label=\"infoset of state %ld in memory %s\"\n", st,
            storage->GetMemoryName().c_str());

    struct State_Info_Header *sthd = storage->GetStateInfo(st);
    if (sthd != NULL)
    {
        Agent::Action acts[sthd->act_num];

        printf("rank=\"same\"\n");
        printf("st%ld [label=\"%ld\\n(%.2f)\"]\n", sthd->st, sthd->st,
                sthd->payoff);
        // action nodes and action ---> action
        printf("subgraph \n{\n");
        printf("rank=\"same\"\n");    // env nodes should be drawing under state node
        printf("node [shape=\"point\"]\n");

        StateInfoParser sparser(sthd);
        Action_Info_Header *achd, *pre_achd = NULL;
        achd = sparser.FirstAct();
        int i = 0;
        while (achd != NULL)
        {
            printf("act%sin%ld [label=\"\", height=0.3]\n",
                    Act2String(achd->act).c_str(), sthd->st);
            if (pre_achd != NULL)
                printf("act%sin%ld -> act%sin%ld [style=dashed, dir=none]\n",
                        Act2String(pre_achd->act).c_str(), sthd->st,
                        Act2String(achd->act).c_str(), sthd->st);

            acts[i++] = achd->act;    // save for using later
            pre_achd = achd;
            achd = sparser.NextAct();
        }
        printf("}\n");    // subgraph

        // state ---> actions
        for (unsigned long i = 0; i < sthd->act_num; i++)
        {
            printf(
                    "st%ld -> act%sin%ld [label=<<font color=\"blue\">%ld</font>>, color=\"blue\", weight=2.]\n",
                    sthd->st, Act2String(acts[i]).c_str(), sthd->st, acts[i]);
        }

        // actions ---> next states
        EnvAction_Info *eaif = NULL;
        achd = sparser.FirstAct();    // restart from beginning
        while (achd != NULL)
        {
            eaif = sparser.FirstEat();
            while (eaif != NULL)
            {
                printf(
                        "act%sin%ld -> st%ld [label=<<font color=\"red\">%ld (%ld)</font>>, color=\"red\", weight=1.]\n",
                        Act2String(achd->act).c_str(), sthd->st, eaif->nst,
                        achd->act, eaif->count);
                // get the payoff of the next state, exclude self
                if (eaif->nst != sthd->st)
                {
                    State_Info_Header *nstif = storage->GetStateInfo(eaif->nst);
                    if (nstif == NULL)    // shouldn't happen
                        ERROR("next state: %ld returns NULL!\n", eaif->nst);

                    printf("st%ld [label=\"%ld\\n(%.2f)\"]\n", eaif->nst,
                            eaif->nst, nstif->payoff);    // print out next state
                    free(nstif);
                }

                eaif = sparser.NextEat();
            }

            achd = sparser.NextAct();
        }

        free(sthd);
    }
    else    // state not found
    {
        printf("state %ld not found in memory!\n", st);
    }

    printf("}\n");    // digraph
    storage->Close();
}

}    // namespace gimcs
